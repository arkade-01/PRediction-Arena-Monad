{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-0f49a3845e972eab25fce032bff017116f89918c",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/PredictionArena.sol": "project/contracts/PredictionArena.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@pythnetwork/pyth-sdk-solidity/=npm/@pythnetwork/pyth-sdk-solidity@4.3.1/",
        "project/:@pythnetwork/pyth-sdk-solidity/=npm/@pythnetwork/pyth-sdk-solidity@4.3.1/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "npm/@pythnetwork/pyth-sdk-solidity@4.3.1/IPyth.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n    /// the returned price is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Returns the required fee to update a TWAP price.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getTwapUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method will not store the price updates on-chain.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime,` but choose to store price updates if `storeUpdatesIfFresh`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// This method will eventually allow the caller to determine whether parsed price feeds should update\n    /// the stored values as well.\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minAllowedPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxAllowedPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @param storeUpdatesIfFresh flag for the parse function to\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdatesWithConfig(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minAllowedPublishTime,\n        uint64 maxAllowedPublishTime,\n        bool checkUniqueness,\n        bool checkUpdateDataIsMinimal,\n        bool storeUpdatesIfFresh\n    )\n        external\n        payable\n        returns (\n            PythStructs.PriceFeed[] memory priceFeeds,\n            uint64[] memory slots\n        );\n\n    /// @notice Parse time-weighted average price (TWAP) from two consecutive price updates for the given `priceIds`.\n    ///\n    /// This method calculates TWAP between two data points by processing the difference in cumulative price values\n    /// divided by the time period. It requires exactly two updates that contain valid price information\n    /// for all the requested price IDs.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the updateData array.\n    ///\n    /// @dev Reverts if:\n    /// - The transferred fee is not sufficient\n    /// - The updateData is invalid or malformed\n    /// - The updateData array does not contain exactly 2 updates\n    /// - There is no update for any of the given `priceIds`\n    /// - The time ordering between data points is invalid (start time must be before end time)\n    /// @param updateData Array containing exactly two price updates (start and end points for TWAP calculation)\n    /// @param priceIds Array of price ids to calculate TWAP for\n    /// @return twapPriceFeeds Array of TWAP price feeds corresponding to the given `priceIds` (with the same order)\n    function parseTwapPriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds\n    )\n        external\n        payable\n        returns (PythStructs.TwapPriceFeed[] memory twapPriceFeeds);\n\n    /// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are\n    /// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,\n    /// this method will return the first update. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range and uniqueness condition.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdatesUnique(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
      },
      "npm/@pythnetwork/pyth-sdk-solidity@4.3.1/IPythEvents.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param publishTime Publish time of the given price update.\n    /// @param price Price of the given price update.\n    /// @param conf Confidence interval of the given price update.\n    event PriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 publishTime,\n        int64 price,\n        uint64 conf\n    );\n\n    /// @dev Emitted when the TWAP price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param startTime Start time of the TWAP.\n    /// @param endTime End time of the TWAP.\n    /// @param twapPrice Price of the TWAP.\n    /// @param twapConf Confidence interval of the TWAP.\n    /// @param downSlotsRatio Down slot ratio of the TWAP.\n    event TwapPriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 startTime,\n        uint64 endTime,\n        int64 twapPrice,\n        uint64 twapConf,\n        uint32 downSlotsRatio\n    );\n}\n"
      },
      "npm/@pythnetwork/pyth-sdk-solidity@4.3.1/PythStructs.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n\n    struct TwapPriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Start time of the TWAP\n        uint64 startTime;\n        // End time of the TWAP\n        uint64 endTime;\n        // TWAP price\n        Price twap;\n        // Down slot ratio represents the ratio of price feed updates that were missed or unavailable\n        // during the TWAP period, expressed as a fixed-point number between 0 and 1e6 (100%).\n        // For example:\n        //   - 0 means all price updates were available\n        //   - 500_000 means 50% of updates were missed\n        //   - 1_000_000 means all updates were missed\n        // This can be used to assess the quality/reliability of the TWAP calculation.\n        // Applications should define a maximum acceptable ratio (e.g. 100000 for 10%)\n        // and revert if downSlotsRatio exceeds it.\n        uint32 downSlotsRatio;\n    }\n\n    // Information used to calculate time-weighted average prices (TWAP)\n    struct TwapPriceInfo {\n        // slot 1\n        int128 cumulativePrice;\n        uint128 cumulativeConf;\n        // slot 2\n        uint64 numDownSlots;\n        uint64 publishSlot;\n        uint64 publishTime;\n        uint64 prevPublishTime;\n        // slot 3\n        int32 expo;\n    }\n}\n"
      },
      "project/contracts/PredictionArena.sol": {
        "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\n\ncontract PredictionArena is ReentrancyGuard {\n    // ============ Structures ============\n    struct Round {\n        uint256 id;\n        string question;\n        bytes32 pythPriceId;      // Pyth price feed ID (if price-based)\n        uint256 entryFee;\n        uint256 startTime;\n        uint256 endTime;\n        int64 outcome;            // resolved value (changed to int64 for Pyth prices)\n        bool resolved;\n        bool cancelled;\n        bool usePyth;             // true = resolve via Pyth oracle\n        address[] players;\n    }\n\n    struct Prediction {\n        address player;\n        int64 value;              // predicted value (int64 for price predictions)\n        uint256 timestamp;\n    }\n\n    struct AgentStats {\n        uint256 wins;\n        uint256 losses;\n        uint256 totalWagered;\n        uint256 totalWon;\n        uint256 roundsPlayed;\n        uint256 bestStreak;\n        uint256 currentStreak;\n        bool isRegistered;\n    }\n\n    // ============ State ============\n    IPyth public pyth;\n    \n    mapping(uint256 => Round) public rounds;\n    mapping(uint256 => mapping(address => Prediction)) public predictions;\n    mapping(uint256 => mapping(address => bool)) public refunded;\n    mapping(address => AgentStats) public agentStats;\n    \n    address[] public registeredAgents;\n    uint256 public roundCount;\n    address public owner;\n\n    // ============ Events ============\n    event RoundCreated(uint256 indexed id, string question, uint256 entryFee, uint256 endTime, bool usePyth);\n    event PredictionSubmitted(uint256 indexed roundId, address indexed player, int64 value);\n    event RoundResolved(uint256 indexed roundId, int64 outcome, address[] winners);\n    event RoundCancelled(uint256 indexed roundId, string reason);\n    event Payout(uint256 indexed roundId, address indexed player, uint256 amount);\n    event RefundClaimed(uint256 indexed roundId, address indexed player, uint256 amount);\n    event TreasuryWithdrawn(uint256 amount);\n    event AgentRegistered(address indexed agent);\n    event AgentStatsUpdated(address indexed agent, uint256 wins, uint256 losses);\n\n    // ============ Modifiers ============\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not authorized\");\n        _;\n    }\n\n    modifier onlyRegisteredAgent() {\n        require(agentStats[msg.sender].isRegistered, \"Agent not registered\");\n        _;\n    }\n\n    // ============ Constructor ============\n    constructor(address _pythAddress) {\n        owner = msg.sender;\n        pyth = IPyth(_pythAddress);\n    }\n\n    // ============ Agent Registration ============\n    function registerAgent() external {\n        require(!agentStats[msg.sender].isRegistered, \"Already registered\");\n        \n        agentStats[msg.sender] = AgentStats({\n            wins: 0,\n            losses: 0,\n            totalWagered: 0,\n            totalWon: 0,\n            roundsPlayed: 0,\n            bestStreak: 0,\n            currentStreak: 0,\n            isRegistered: true\n        });\n        \n        registeredAgents.push(msg.sender);\n        emit AgentRegistered(msg.sender);\n    }\n\n    function getRegisteredAgents() external view returns (address[] memory) {\n        return registeredAgents;\n    }\n\n    function getAgentStats(address _agent) external view returns (AgentStats memory) {\n        return agentStats[_agent];\n    }\n\n    // ============ Round Management ============\n    function createRound(\n        string memory _question,\n        uint256 _entryFee,\n        uint256 _duration\n    ) external onlyOwner {\n        _createRound(_question, bytes32(0), _entryFee, _duration, false);\n    }\n\n    function createPythRound(\n        string memory _question,\n        bytes32 _pythPriceId,\n        uint256 _entryFee,\n        uint256 _duration\n    ) external onlyOwner {\n        _createRound(_question, _pythPriceId, _entryFee, _duration, true);\n    }\n\n    function _createRound(\n        string memory _question,\n        bytes32 _pythPriceId,\n        uint256 _entryFee,\n        uint256 _duration,\n        bool _usePyth\n    ) internal {\n        roundCount++;\n        Round storage newRound = rounds[roundCount];\n        newRound.id = roundCount;\n        newRound.question = _question;\n        newRound.pythPriceId = _pythPriceId;\n        newRound.entryFee = _entryFee;\n        newRound.startTime = block.timestamp;\n        newRound.endTime = block.timestamp + _duration;\n        newRound.usePyth = _usePyth;\n        \n        emit RoundCreated(roundCount, _question, _entryFee, newRound.endTime, _usePyth);\n    }\n\n    // ============ Predictions ============\n    function submitPrediction(uint256 _roundId, int64 _value) external payable nonReentrant onlyRegisteredAgent {\n        require(_roundId > 0 && _roundId <= roundCount, \"Invalid round ID\");\n        Round storage round = rounds[_roundId];\n        \n        require(!round.cancelled, \"Round cancelled\");\n        require(!round.resolved, \"Round resolved\");\n        require(block.timestamp < round.endTime, \"Round ended\");\n        require(msg.value == round.entryFee, \"Incorrect entry fee\");\n        require(predictions[_roundId][msg.sender].timestamp == 0, \"Already predicted\");\n\n        predictions[_roundId][msg.sender] = Prediction({\n            player: msg.sender,\n            value: _value,\n            timestamp: block.timestamp\n        });\n\n        round.players.push(msg.sender);\n        \n        // Update agent stats\n        agentStats[msg.sender].totalWagered += msg.value;\n        agentStats[msg.sender].roundsPlayed++;\n        \n        emit PredictionSubmitted(_roundId, msg.sender, _value);\n    }\n\n    // ============ Resolution ============\n    function resolveRound(uint256 _roundId, int64 _outcome) external onlyOwner nonReentrant {\n        require(_roundId > 0 && _roundId <= roundCount, \"Invalid round ID\");\n        Round storage round = rounds[_roundId];\n        require(!round.usePyth, \"Use resolveWithPyth for oracle rounds\");\n        \n        _resolveRound(_roundId, _outcome);\n    }\n\n    function resolveWithPyth(uint256 _roundId, bytes[] calldata priceUpdateData) external payable onlyOwner nonReentrant {\n        require(_roundId > 0 && _roundId <= roundCount, \"Invalid round ID\");\n        Round storage round = rounds[_roundId];\n        require(round.usePyth, \"Not a Pyth round\");\n        \n        // Update Pyth price\n        uint256 fee = pyth.getUpdateFee(priceUpdateData);\n        pyth.updatePriceFeeds{value: fee}(priceUpdateData);\n        \n        // Get price (use getPriceUnsafe since we just updated)\n        PythStructs.Price memory price = pyth.getPriceUnsafe(round.pythPriceId);\n        \n        _resolveRound(_roundId, price.price);\n    }\n\n    function _resolveRound(uint256 _roundId, int64 _outcome) internal {\n        Round storage round = rounds[_roundId];\n        \n        require(!round.resolved, \"Already resolved\");\n        require(!round.cancelled, \"Already cancelled\");\n        require(block.timestamp > round.endTime, \"Round not ended\");\n\n        // Validate minimum players\n        if (round.players.length < 2) {\n            _cancelRound(_roundId, \"Insufficient players\");\n            return;\n        }\n\n        round.outcome = _outcome;\n        round.resolved = true;\n\n        uint256 minDelta = type(uint256).max;\n        \n        // First pass: find minimum delta\n        for (uint256 i = 0; i < round.players.length; i++) {\n            address playerAddr = round.players[i];\n            int64 predictionVal = predictions[_roundId][playerAddr].value;\n            uint256 delta = _absDiff(predictionVal, _outcome);\n            \n            if (delta < minDelta) {\n                minDelta = delta;\n            }\n        }\n\n        // Second pass: identify winners\n        address[] memory winners = new address[](round.players.length);\n        uint256 winnerCount = 0;\n        \n        for (uint256 i = 0; i < round.players.length; i++) {\n            address playerAddr = round.players[i];\n            int64 predictionVal = predictions[_roundId][playerAddr].value;\n            uint256 delta = _absDiff(predictionVal, _outcome);\n\n            if (delta == minDelta) {\n                winners[winnerCount] = playerAddr;\n                winnerCount++;\n            }\n        }\n\n        // Update stats for all players\n        for (uint256 i = 0; i < round.players.length; i++) {\n            address playerAddr = round.players[i];\n            bool isWinner = false;\n            \n            for (uint256 j = 0; j < winnerCount; j++) {\n                if (winners[j] == playerAddr) {\n                    isWinner = true;\n                    break;\n                }\n            }\n            \n            if (isWinner) {\n                agentStats[playerAddr].wins++;\n                agentStats[playerAddr].currentStreak++;\n                if (agentStats[playerAddr].currentStreak > agentStats[playerAddr].bestStreak) {\n                    agentStats[playerAddr].bestStreak = agentStats[playerAddr].currentStreak;\n                }\n            } else {\n                agentStats[playerAddr].losses++;\n                agentStats[playerAddr].currentStreak = 0;\n            }\n            \n            emit AgentStatsUpdated(playerAddr, agentStats[playerAddr].wins, agentStats[playerAddr].losses);\n        }\n\n        // Payout\n        uint256 roundPot = round.players.length * round.entryFee;\n        uint256 rewardPerWinner = roundPot / winnerCount;\n\n        address[] memory finalWinners = new address[](winnerCount);\n        for(uint i = 0; i < winnerCount; i++) {\n            finalWinners[i] = winners[i];\n            agentStats[winners[i]].totalWon += rewardPerWinner;\n            \n            (bool success, ) = payable(winners[i]).call{value: rewardPerWinner}(\"\");\n            require(success, \"Payout failed\");\n            \n            emit Payout(_roundId, winners[i], rewardPerWinner);\n        }\n\n        emit RoundResolved(_roundId, _outcome, finalWinners);\n    }\n\n    function _absDiff(int64 a, int64 b) internal pure returns (uint256) {\n        if (a > b) {\n            return uint256(uint64(a - b));\n        } else {\n            return uint256(uint64(b - a));\n        }\n    }\n\n    // ============ Cancellation & Refunds ============\n    function cancelRound(uint256 _roundId) external onlyOwner {\n        _cancelRound(_roundId, \"Admin cancelled\");\n    }\n\n    function _cancelRound(uint256 _roundId, string memory reason) internal {\n        Round storage round = rounds[_roundId];\n        require(!round.resolved, \"Cannot cancel resolved\");\n        require(!round.cancelled, \"Already cancelled\");\n        \n        round.cancelled = true;\n        emit RoundCancelled(_roundId, reason);\n    }\n\n    function claimRefund(uint256 _roundId) external nonReentrant {\n        Round storage round = rounds[_roundId];\n        require(round.cancelled, \"Round not cancelled\");\n        require(predictions[_roundId][msg.sender].timestamp != 0, \"Not a participant\");\n        require(!refunded[_roundId][msg.sender], \"Already refunded\");\n\n        refunded[_roundId][msg.sender] = true;\n        uint256 refundAmount = round.entryFee;\n\n        (bool success, ) = payable(msg.sender).call{value: refundAmount}(\"\");\n        require(success, \"Refund failed\");\n\n        emit RefundClaimed(_roundId, msg.sender, refundAmount);\n    }\n\n    // ============ Views ============\n    function getRoundPlayers(uint256 _roundId) external view returns (address[] memory) {\n        return rounds[_roundId].players;\n    }\n\n    function getLeaderboard() external view returns (address[] memory, uint256[] memory) {\n        uint256 len = registeredAgents.length;\n        address[] memory agents = new address[](len);\n        uint256[] memory scores = new uint256[](len);\n        \n        for (uint256 i = 0; i < len; i++) {\n            agents[i] = registeredAgents[i];\n            scores[i] = agentStats[registeredAgents[i]].wins;\n        }\n        \n        // Simple bubble sort (fine for small lists)\n        for (uint256 i = 0; i < len; i++) {\n            for (uint256 j = i + 1; j < len; j++) {\n                if (scores[j] > scores[i]) {\n                    (scores[i], scores[j]) = (scores[j], scores[i]);\n                    (agents[i], agents[j]) = (agents[j], agents[i]);\n                }\n            }\n        }\n        \n        return (agents, scores);\n    }\n\n    // ============ Admin ============\n    function withdrawTreasury(uint256 _amount) external onlyOwner {\n        require(_amount <= address(this).balance, \"Insufficient balance\");\n        (bool success, ) = payable(owner).call{value: _amount}(\"\");\n        require(success, \"Withdraw failed\");\n        \n        emit TreasuryWithdrawn(_amount);\n    }\n\n    function updatePythAddress(address _newPyth) external onlyOwner {\n        pyth = IPyth(_newPyth);\n    }\n\n    receive() external payable {}\n}\n"
      }
    }
  }
}